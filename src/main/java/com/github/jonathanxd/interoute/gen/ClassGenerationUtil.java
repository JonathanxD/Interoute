/*
 *      Interoute - Interface routing framework. <https://github.com/JonathanxD/Interoute>
 *
 *         The MIT License (MIT)
 *
 *      Copyright (c) 2018 TheRealBuggy/JonathanxD (https://github.com/JonathanxD/) <jonathan.scripter@programmer.net>
 *      Copyright (c) contributors
 *
 *
 *      Permission is hereby granted, free of charge, to any person obtaining a copy
 *      of this software and associated documentation files (the "Software"), to deal
 *      in the Software without restriction, including without limitation the rights
 *      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *      copies of the Software, and to permit persons to whom the Software is
 *      furnished to do so, subject to the following conditions:
 *
 *      The above copyright notice and this permission notice shall be included in
 *      all copies or substantial portions of the Software.
 *
 *      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *      THE SOFTWARE.
 */
package com.github.jonathanxd.interoute.gen;

import com.github.jonathanxd.interoute.backend.InterouteBackend;
import com.github.jonathanxd.interoute.backend.InterouteBackendConfiguration;
import com.github.jonathanxd.interoute.exception.FactoryException;
import com.github.jonathanxd.iutils.collection.Collections3;
import com.github.jonathanxd.iutils.object.result.Result;
import com.github.jonathanxd.kores.base.ClassDeclaration;
import com.github.jonathanxd.kores.bytecode.BytecodeClass;
import com.github.jonathanxd.kores.bytecode.BytecodeOptions;
import com.github.jonathanxd.kores.bytecode.VisitLineType;
import com.github.jonathanxd.kores.bytecode.classloader.CodeClassLoader;
import com.github.jonathanxd.kores.bytecode.processor.BytecodeGenerator;
import com.github.jonathanxd.kores.bytecode.util.ClassSaveUtilKt;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

/**
 * {@link Class} generation utility.
 */
public final class ClassGenerationUtil {
    private static final String SAVE_PATH = System.getProperty("interoute.debug.save_dir", null);
    private static final MethodHandles.Lookup lookup = MethodHandles.publicLookup();

    /**
     * Generates {@link BytecodeClass bytecode classes} from {@code classDeclaration}.
     *
     * @param classDeclaration Class declaration to generate bytecode classes.
     * @return Generated bytecode classes.
     */
    public static List<BytecodeClass> generate(ClassDeclaration classDeclaration) {
        BytecodeGenerator bytecodeGenerator = new BytecodeGenerator(named -> named.getName() + ".interoute");
        bytecodeGenerator.getOptions().set(BytecodeOptions.VISIT_LINES, VisitLineType.GEN_LINE_INSTRUCTION);
        return bytecodeGenerator.process(classDeclaration);
    }

    /**
     * Load {@link BytecodeClass bytecode classes} with a child classloader parenting to {@code classLoader} or directly into
     * {@code classLoader} if it is a {@link CodeClassLoader}.
     *
     * @param bytecodeClasses Classes to load.
     * @param classLoader     Parent loader or {@link CodeClassLoader loader} to use.
     * @param <T>             Expected class type.
     * @return Loaded class instance.
     */
    @SuppressWarnings("unchecked")
    public static <T> Class<? extends T> load(List<BytecodeClass> bytecodeClasses, ClassLoader classLoader) {
        CodeClassLoader loader;

        if (classLoader == null) {
            loader = new CodeClassLoader();
        } else if (classLoader instanceof CodeClassLoader) {
            loader = (CodeClassLoader) classLoader;
        } else {
            loader = new CodeClassLoader(classLoader);
        }

        if (SAVE_PATH != null) {
            Path path = Paths.get(SAVE_PATH);

            for (BytecodeClass bytecodeClass : bytecodeClasses) {
                ClassSaveUtilKt.save(bytecodeClass, path, true, true);
            }
        }


        return (Class<T>) loader.define(bytecodeClasses);
    }

    /**
     * Creates {@link T router instance}.
     *
     * @param clazz          Router implementation class.
     * @param argumentsTypes Argument types of the implementation class constructor.
     * @param arguments      Arguments to pass to constructor.
     * @param <T>            Router type.
     * @return Router instance.
     */
    @SuppressWarnings("unchecked")
    public static <T> Result<T, FactoryException> create(Class<T> clazz, List<Class<?>> argumentsTypes, List<Object> arguments) {
        if (argumentsTypes.size() != arguments.size())
            throw new IllegalArgumentException("'argumentTypes' list must have same amount of elements as 'arguments' list.");

        try {
            return Result.ok((T) lookup.findConstructor(clazz,
                    MethodType.methodType(Void.TYPE, argumentsTypes)).invokeWithArguments(arguments));
        } catch (Throwable t) {
            return Result.error(new FactoryException(t));
        }
    }

    /**
     * Creates {@link T router instance} with {@code backend} and {@code configuration} as constructor arguments.
     *
     * @param clazz Router implementation class.
     * @param <T>   Router type.
     * @return Router instance.
     */
    @SuppressWarnings("unchecked")
    public static <T> Result<T, FactoryException> create(Class<T> clazz, InterouteBackend<?> backend,
                                                         InterouteBackendConfiguration configuration) {
        return ClassGenerationUtil.create(
                clazz,
                Collections3.listOf(InterouteBackend.class, InterouteBackendConfiguration.class),
                Collections3.listOf(backend, configuration)
        );
    }
}
